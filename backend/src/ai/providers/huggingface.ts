import {
  AIProvider,
  AIModality,
  TextToTextRequest,
  TextToTextResponse,
  AIProviderError,
  UnsupportedModalityError
} from '../interfaces';

export interface HuggingFaceConfig {
  apiKey: string;
  baseUrl?: string;
  model?: string;
}

export class HuggingFaceProvider implements AIProvider {
  readonly name = 'huggingface';
  readonly supportedModalities = [AIModality.TextToText];

  private apiKey: string;
  private baseUrl: string;
  private model: string;

  constructor(config: HuggingFaceConfig) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://api-inference.huggingface.co';
    this.model = config.model || 'mistralai/Mistral-7B-Instruct-v0.3';
  }

  async generateText(request: TextToTextRequest): Promise<TextToTextResponse> {
    if (!this.supportedModalities.includes(AIModality.TextToText)) {
      throw new UnsupportedModalityError(AIModality.TextToText, this.name);
    }

    try {
      // Convert messages to HuggingFace format
      const prompt = this.formatMessages(request.messages);
      
      const payload = {
        inputs: prompt,
        parameters: {
          temperature: request.temperature,
          max_new_tokens: request.maxTokens,
          return_full_text: false,
          ...(request.stopSequences && { stop: request.stopSequences })
        }
      };

      console.log(`Calling HuggingFace API with model: ${this.model}`);
      
      const response = await fetch(
        `${this.baseUrl}/models/${this.model}`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        console.error('HuggingFace API Error Response:', errorText);
        
        // Handle specific HuggingFace error cases
        if (response.status === 503) {
          throw new AIProviderError(
            'HuggingFace model is loading, please try again later',
            this.name,
            errorText
          );
        }
        
        throw new AIProviderError(
          `HuggingFace API error: ${errorText}`,
          this.name,
          errorText
        );
      }

      const data = await response.json() as any;
      console.log('HuggingFace API Response structure:', JSON.stringify({
        dataType: Array.isArray(data) ? 'array' : typeof data,
        arrayLength: Array.isArray(data) ? data.length : 'N/A',
        hasGeneratedText: Array.isArray(data) && data[0]?.generated_text !== undefined
      }));
      
      if (!Array.isArray(data) || data.length === 0) {
        throw new AIProviderError(
          'No response generated by HuggingFace',
          this.name
        );
      }

      const result = data[0];
      let content = result.generated_text || '';

      if (!content.trim()) {
        throw new AIProviderError(
          'Empty response generated by HuggingFace',
          this.name
        );
      }

      return {
        content: content.trim()
      };

    } catch (error) {
      if (error instanceof AIProviderError) {
        throw error;
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('HuggingFace Provider Error:', errorMessage, error);
      throw new AIProviderError(
        `Failed to generate text: ${errorMessage}`,
        this.name,
        error
      );
    }
  }

  private formatMessages(messages: Array<{ role: string; content: string }>): string {
    // Convert conversation to simple prompt format
    let prompt = '';
    
    for (const message of messages) {
      if (message.role === 'system') {
        prompt += `${message.content}\n\n`;
      } else if (message.role === 'user') {
        prompt += `Human: ${message.content}\n\n`;
      } else if (message.role === 'assistant') {
        prompt += `Assistant: ${message.content}\n\n`;
      }
    }
    
    // Add final prompt for assistant response
    prompt += 'Assistant: ';
    
    return prompt;
  }
} 