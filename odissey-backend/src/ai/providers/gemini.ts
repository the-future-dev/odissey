import {
  AIProvider,
  AIModality,
  TextToTextRequest,
  TextToTextResponse,
  AIProviderError,
  UnsupportedModalityError
} from '../interfaces';

export interface GeminiConfig {
  apiKey: string;
  baseUrl?: string;
  model?: string;
}

export class GeminiProvider implements AIProvider {
  readonly name = 'gemini';
  readonly supportedModalities = [AIModality.TextToText];

  private apiKey: string;
  private baseUrl: string;
  private model: string;

  constructor(config: GeminiConfig) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://generativelanguage.googleapis.com/v1';
    this.model = config.model || 'gemini-pro';
  }

  async generateText(request: TextToTextRequest): Promise<TextToTextResponse> {
    if (!this.supportedModalities.includes(AIModality.TextToText)) {
      throw new UnsupportedModalityError(AIModality.TextToText, this.name);
    }

    try {
      // Convert messages to Gemini format
      const contents = this.formatMessages(request.messages);
      
      const payload = {
        contents,
        generationConfig: {
          temperature: request.temperature || 0.7,
          maxOutputTokens: request.maxTokens || 500,
          ...(request.stopSequences && { stopSequences: request.stopSequences })
        }
      };

      const response = await fetch(
        `${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new AIProviderError(
          `Gemini API error: ${errorText}`,
          this.name,
          AIModality.TextToText,
          response.status
        );
      }

      const data = await response.json() as any;
      
      if (!data.candidates || data.candidates.length === 0) {
        throw new AIProviderError(
          'No response generated by Gemini',
          this.name,
          AIModality.TextToText
        );
      }

      const candidate = data.candidates[0];
      const content = candidate.content?.parts?.[0]?.text || '';

      return {
        content,
        model: this.model,
        finishReason: candidate.finishReason || 'stop'
      };

    } catch (error) {
      if (error instanceof AIProviderError) {
        throw error;
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new AIProviderError(
        `Failed to generate text: ${errorMessage}`,
        this.name,
        AIModality.TextToText
      );
    }
  }

  private formatMessages(messages: Array<{ role: string; content: string }>) {
    const contents = [];
    
    for (const message of messages) {
      if (message.role === 'system') {
        // Gemini doesn't have a system role, so we'll add it as part of the first user message
        continue;
      }
      
      contents.push({
        role: message.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: message.content }]
      });
    }
    
    // Add system message to first user message if exists
    const systemMessage = messages.find(m => m.role === 'system');
    if (systemMessage && contents.length > 0 && contents[0].role === 'user') {
      contents[0].parts[0].text = `${systemMessage.content}\n\n${contents[0].parts[0].text}`;
    }
    
    return contents;
  }
} 